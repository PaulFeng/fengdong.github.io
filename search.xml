<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Promise的使用]]></title>
    <url>%2F2018%2F08%2F14%2Fuse-of-promise%2F</url>
    <content type="text"><![CDATA[Promise 使用1.实例化1234567// 实例化promise，内部定义的函数会立马执行function resolver(resolve, reject) &#123; setTimeout(function() &#123; resolve(‘hello world’) &#125;, 100)&#125;var promise = new Promise(resolver) 2.实例化不是函数的参数123// 如果实例化时传入的参数不是函数则会报错var promise = new Promise(111);// Uncaught TypeError: Promise resolver 111 is not a function 3.then/catch12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// then方法有两个参数// 第一个参数如果是函数，只有promise resolve时才会执行；如果不是函数则会忽略// 第二个参数只有reject时才会执行var promise = new Promise(function (resolve, reject) &#123; setTimeout(function() &#123; resolve(‘hello world’) &#125;, 100)&#125;)promise.then(function (res) &#123; console.log(res)&#125;, function (err) &#123; console.log(err)&#125;)// 100ms后打印‘hello world’// catch方法只有一个参数，promise reject时执行var promise1 = new Promise(function (resolve, reject) &#123; setTimeout(function() &#123; reject('something wrong’) &#125;, 100)&#125;)promise1.then(function(res) &#123; console.log(res)&#125;).catch(function(err) &#123; console.log(err)&#125;)// 100ms后打印‘something wrong’// 再看一个改变题，接上一个定义的promise1promise1.then(function(res) &#123; console.log(res)&#125;, function(err) &#123; console.log('then err: ' + err)&#125;).catch(function(err) &#123; console.log('catch err: ' + err)&#125;)// 100ms后仅打印‘then err: something wrong’// promise1只有在执行错误或者then第二个参数返回promise为reject时才会执行catch参数方法promise1.then(function(res) &#123; console.log(res)&#125;, 'reject').catch(function(err) &#123; console.log('catch err: ' + err)&#125;)// 100ms后打印‘catch err: something wrong’// 如果then第二个参数不是函数，则会被忽略，并且then返回的promise会执行catch参数// 同一个promise多次调用thenpromise.then(function(res) &#123;console.log('then1: ' + res)&#125;)promise.then(function(res) &#123;console.log('then2: ' + res)&#125;)// 一个promise添加了多个then，当promise resolve时会依次执行then执行栈，并且每个回调的值是一样的// 多个then执行栈，但是同时链接了一个promise.then(function(res) &#123; console.log('then1: ' + res) return 'then1'&#125;).then(function(res) &#123; console.log('then3: ' + res)&#125;)promise.then(function(res) &#123; console.log('then2: ' + res)&#125; return 'then2')// 依次打印// "then1: hello world"// "then2: hello world"// "then3: then1"// resolve返回promise与then/catch返回promise的区别// promise2 = promise1.then(() =&gt; promise3)// promise1 resolve返回promise，则promise1必须等待resolve的promise执行结果，并且依据其最终状态来改变自己的状态// promise2需等待promise3的执行结果，依据promise3的执行结果// 其实处理过程时相同的，then方法添加到执行栈时会执行then函数，如果返回的是promise，则会执行promise.then(),然后满足则执行resolve(promise2, value)var resolvePromise = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(new Promise(function(resolve, reject) &#123; reject('resolve promise error') &#125;)) &#125;)&#125;)resolvePromise.then(function(res) &#123; console.log(res)&#125;).catch(function (err) &#123; console.log('catch: ' + err)&#125;)// 最终输出‘catch： resolve promise error’// Promise.all(iterable)/Promise.race(iterable) iterable所有的promise实例都会执行，并且无法中断，当然除非自己做标记进行终止 题一123456789101112131415161718console.log(111);var s = new Promise((resolve, reject) =&gt; &#123; console.log(22); resolve( new Promise(resolve =&gt; &#123; console.log(555); resolve(444); &#125;) ); console.log(3333);&#125;);s.then(res =&gt; console.log(res));// 111// 22// 555// 3333// 44 题二1234567891011121314console.log(111);var s = new Promise((resolve, reject) =&gt; &#123; console.log(22); resolve(function() &#123; console.log(555); &#125;); console.log(3333);&#125;);s.then(res =&gt; console.log(res));// 111// 22// 3333// ƒ () &#123;console.log(555)&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Promise/A+规范]]></title>
    <url>%2F2018%2F07%2F28%2Fimplementation-of-promise%2F</url>
    <content type="text"><![CDATA[初衷为了了解Promise实现原理，查看了很多博客，并且翻阅了Promise/A+规范；由于很多实现都比较基础，并未详细介绍并处理很多细节，所以整理后，将自己的实现思路以及处理细节记录下来。 Promise简介Javascript作为单线程机制，无法同时执行多个任务（当然，H5新增Web Worker可以在js线程外执行任务），所以异步编程的方式都是通过回调或者事件监听方式解决(具体可参考：阮一峰博客：Javascript异步编程的4种方法)；这也造成多个Javascript异步任务的处理会出现“callback hell”(回调地狱)，使得这部分代码难以维护，并且很难读懂。 所以，Javascript社区的大牛们就提出解决这种回调地狱的模式（Promise），最初的实现方案有jQuery的deferred，when，q等；现在，最流行的是 Promise/A+ 规范。 这里不再赘述Promise/A+规范，详细可查看文章底部链接。 Promise的使用详见… Promise 简单实现构造函数和then首先实现一个最简化版的功能，在使用Promise时，会传入我们的异步操作，并且默认有两个参数 resolve 和 reject ；这里我们先实现Promise resolve和then的简单功能：12345678910111213function Promise(resolver) &#123; this.callback = function() &#123;&#125; function resolve(value) &#123; this.callback(value) &#125; resolver(resolve.bind(this))&#125;Promise.prototype.then = function (fn) &#123; this.callback = fn&#125; 上面定义的构造函数中，实例化Promise并添加then方法时，会将then方法的参数保存为回调，以保证resolve时执行回调，现在测试一下:123456789var promise = new Promise(function (resolve) &#123; setTimeout(function() &#123; resolve('resolve') &#125;, 100)&#125;)promise.then(function(res) &#123; console.log(res)&#125;)// 100ms后打印'resolve' 注意：上面的构造函数存在一个问题，使用原生Promise时我们并不总是传递异步函数，也可能是同步的，这个时候我们上面的then方法就会不执行[1]，这个后面讨论。 链式调用链式调用的实现就是在then方法中返回this自身就可以了，首先我们需要将回调函数改为数组，用来存储每次执行then时的回调函数：12345678910111213141516function Promise(resolver) &#123; this._resolveCallbacks = [] function resolve(value) &#123; this._resolveCallbacks.forEach(function(callback) &#123; callback(value) &#125;) &#125; resolver(resolve.bind(this))&#125;Promise.prototype.then = function (fn) &#123; this._resolveCallbacks.push(fn) return this&#125; 测试：1234567var promise = new Promise(function(resolve) &#123; setTimeout(function() &#123;resolve('resolve')&#125;,0)&#125;) .then(res =&gt; console.log(res)) .then(res =&gt; console.log(res))// 'resolve'// 'resolve' 这样子就实现了，但是存在问题就是同一个Promise实例的所有then回调执行时的value都是同一个值，链式then回调中返回新值无法在下一个回调中使用[2]。123456var promise = new Promise(function(resolve) &#123; setTimeout(function() &#123;resolve('resolve')&#125;,0)&#125;) .then(res =&gt; &#123;console.log(res); return 'new resolve'&#125;) .then(res =&gt; console.log(res))// 即最后一个then执行的也是'resolve'，并不符合Promise预期 ========================== 分界线 ============================== Promise具体实现下面针对Promise/A+规范对具体细节处理过程进行解剖 Promise状态根据Promise/A+规范，Promise应该有三个状态： Pending(等待) Fulfilled(满足/执行) 当满足时，当前Promise必须有一个终值（value） Rejected(拒绝) 当拒绝时，必须有一个拒因（reason） Pending状态可以转变为Fulfilled或者Rejected;Fulfilled/Rejected不可以再转变为其他任何状态（状态不可逆）; 所以我们定义三个状态：123var PENDING = 0var FULFILLED = 1var REJECTED = 2 接下来，引入状态机制并加入reject状态回调；初始promise的状态为PENDING，当resolve时将状态更改为FULFILLED，reject时更改为REJECTED，构造函数如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function Promise(resolver) &#123; // resolver必须是一个函数，与es6实现相同 if (!isFunction(resolver)) &#123; throw new TypeError('TypeError: Promise resolver ' + resolver.toString() + ' is not a function') &#125; this._status = PENDING this._value = undefined this._reason = undefined this._resolveCallbacks = [] this._rejectCallbacks = [] // new Promise((resolve, reject) =&gt; &#123;&#125;) // 立即调用实例化时的参数，并传递resolve和reject参数 resolver( // 即传递给构造函数参数的resolve参数 function (value) &#123; // Promise需要确保then函数的onFulfilled与onRejected函数异步执行 // 即针对角标[1]的问题，就算promise构造函数参数不是异步执行， // 也必须确保在resolve/reject执行时then回调函数已经添加到回调栈中（即_resolveCallbacks/_rejectCallbacks） setTimeout(function () &#123; // 该处理过程后面会讲，这里暂时可以理解为调用resolve方法 solveProcess(promise, value) &#125;, 0) &#125;, function (reason) &#123; setTimeout(function () &#123; reject(promise, reason) &#125;, 0) &#125; )&#125;// resolve方法function resolve (promise, value) &#123; // 确保resolve只能执行一次 if (promise._status) &#123; return &#125; promise._status = FULFILLED promise._value = value for (var index = 0, len = promise._resolveCallback.length; index &lt; len; index++) &#123; promise._resolveCallback[index](value) &#125;&#125;// reject方法，改变promise状态，执行回调function reject (promise, reason) &#123; if (promise._status) &#123; return &#125; promise._status = REJECTED promise._reason = reason for (var index = 0, len = promise._rejectCallback.length; index &lt; len; index++) &#123; promise._rejectCallback[index](reason) &#125;&#125; 构造函数定义时有几个重点： 构造函数参数resolver必须是一个函数，否则抛出错误 resolve,reject实现中回调函数的调用必须异步执行（我的实现是直接在resolve中异步） resolve,reject方法必须确保只执行一次 Then函数—重中之重关于Then方法的几点描述需要注意： 1.Promise必须包含一个then方法以访问其当前值、终值和据因 2.then方法接收两个参数：onFulfilled和onRejected 3.then方法必须返回一个Promise对象（这个是实现Promise链式调用的关键） 简单实现并修改then方法：12345678910111213141516171819202122232425Promise.prototype.then = function (onFulfilled, onRejected) &#123; var promise = this var promise2 = new Promise(function(resolve, reject) &#123; function handleResolve(value) &#123; var _value = typeof onFulfilled === 'function' ? onFulfilled(value) : value resolve(_value) &#125; function handleReject(reason) &#123; var _reason = typeof onRejected ? onRejected(_reason) : reason reject(_reason) &#125; if (promise._status === PENDING) &#123; promise._resolveCallbacks.push(handleResolve) promise._rejectCallbacks.push(handleReject) &#125; else if (promise._status === FULFILLED) &#123; handleResolve(promise._value) &#125; else if (promise._status === REJECTED) &#123; handleReject(promise._reason) &#125; &#125;) return promise2&#125; 处理步骤如下： 当调用then方法时，首先定义promise变量保存当前Promise实例 定义一个新的promise2（then方法返回的），实例化时判断promise（以下都指代当前Promise实例）的状态 如果是PENDING状态，则将onFulfilled、onRejected包装后的回调函数添加到promise的回调栈中 如果是FULFILLED，则将promise的当前value作为参数执行promise2的resolve（将promise的状态传递到promise2） 如果是REJECTED，则将promise的当前reason作为参数执行promise2的reject 根据Promise/A+规范，onFulfilled/onRejected函数的返回值不同，进行的处理过程是不同的，并且思考： 链式调用过程中如何改变下个promise的状态 resolver函数的参数resolve如果处理的Promise实例与then方法中返回Promise的区别是什么，会产生怎样的影响 带着疑问，一起探讨下promise的处理过程 Promise处理过程到目前为止的实现方案存在诸多问题，then函数根据规范需处理：promise2 = promise1.then(onFulfilled, onRejected) onFulfilled/onRejected如果不是函数，需忽略，根据promise1的执行状态及结果执行promise2。(即promise1执行成功，则执行promise2的resolve，参数为promise1的结果值；反之亦然) 如果onFulfilled/onRejected返回一个值x，则按照规范的解决过程进行处理[[Resolve]](promise2, x)。并且处理结束后promise2成功执行（即promise2的resolve），注意：只有抛出异常时才会执行promise2的reject 处理过程具体看规范，这里直接上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970function solveProcess (promise, x) &#123; // 1.判断返回值x是否指向了promise，避免死循环，抛出异常 if (x === promise) &#123; // x与初始promise为同一个Promise，会造成死循环 var reason = new TypeError('TypeError: A promises callback cannot return that same promise.') reject(promise, reason) &#125; // 2.x是否为Promise实例，如果是，则根据x的执行结果，promise执行对应的resolve/reject else if (x instanceof Promise) &#123; // 如果x为Promise，则父Promise等待其fulfilled或reject x.then( function (value) &#123; resolve(promise, value) &#125;, function (error) &#123; reject(promise, error) &#125; ) &#125; else &#123; // 3.如果以上两点都不是则判断x是否为thenable函数或对象 tryThenable(promise, x, action, isCallback) &#125;&#125;function tryThenable (promise, x) &#123; // 4.x是否对象或函数,如果不是，则以x为值，调用resolve() if (objectOrFunction(x)) &#123; var then = null // 5.获取x.then，如果取出异常则reject promise try &#123; then = x.then &#125; catch (error) &#123; reject(promise, error) &#125; // 6.x为thenable则执行then方法（相当于处理Promise） // 否则以x为值，调用resolve() if (isFunction(then)) &#123; // 7.then方法的resolvePromise和rejectPromise只允许执行一次，sealed做限制 // 如果rejectPromise执行了，则结束promise，并以r为据因 // 如果resolvePromise被调用则以参数y继续执行处理过程 var sealed = false try &#123; then.call( x, /* eslint-disable no-undef */ function resolvePromise (y) &#123; if (sealed) return sealed = true solveProcess(promise, y) &#125;, function rejectPromise (r) &#123; if (sealed) return sealed = true reject(promise, r) &#125; ) &#125; catch (error) &#123; reject(promise, error) &#125; &#125; else &#123; resolve(promise, x) &#125; &#125; else &#123; resolve(promise, x) &#125;&#125;function isFunction (fn) &#123; return typeof fn === 'function'&#125; 代码中第7点处理步骤与第2点处理步骤有区别，虽然都有then方法，但是第二点中x已经为Promise实例了，所以resolvePromise中直接调用了resolve方法，如果该实例resolve了一个新的Promise，则会等待执行结果后才会继续执行；第7点中x不是Promise实例，所以需要不停的手动调用处理过程，因为他并不会等待内部thenable的执行结果。 到这里，可以联系构造函数resolve函数，其实处理过程就这个再看上面我提出的问题，resolve如果参数是promise1则当前promise需等待promise1执行完成，promise的状态继承promise1的状态并执行相应回调 增加onFulfilled/onRejected回调生成函数1234567891011121314151617181920212223242526272829303132/** * 生成promise执行栈函数，说明： * e.g. promise2 = promise1.then(onFulfilled, onRejected) * 根据Promise/A+规范，onFulfilled/onRejected依赖于上一个promise.then()返回的新的promise2 * 并且针对执行返回值定义了一系列处理流程，所以对onFulfilled/onRejected进行闭包封装处理函数并保存在上一个promise的执行栈中 * 即规范中的[[Resolve]](promise2, x) * @param &#123;Promise&#125; promise promise * @param &#123;Any&#125; callback onFulfilled/onRejected * @param &#123;'resolve'|'reject'&#125; action 执行状态 * @return &#123;Function&#125; resolve/reject回调函数 */function makeCallback (promise, callback, action) &#123; // 以下注释x均表示onFulfilled/onRejected函数返回值 return function (value) &#123; var x = null // onFulfilled 和 onRejected 都是可选参数，如果不是函数会被忽略，不添加到执行栈中。 // 并且继承上一个promise的执行状态及执行结果 if (isFunction(callback)) &#123; try &#123; x = callback(value) &#125; catch (error) &#123; reject(promise, error) &#125; solveProcess(promise, x, action, true) &#125; else &#123; action === 'resolve' ? resolve(promise, value) : reject(promise, value) &#125; &#125;&#125; 重构then方法1234567891011121314151617181920Promise.prototype.then = function (onFulfilled, onRejected) &#123; var promise = new Promise(function() &#123;&#125;) switch (this._status) &#123; case PENDING: this._resolveCallback.push(makeCallback(promise, onFulfilled, 'resolve')) this._rejectCallback.push(makeCallback(promise, onRejected, 'reject')) break case FULFILLED: makeCallback(promise, onFulfilled, 'resolve')(this._value) break case REJECTED: makeCallback(promise, onRejected, 'reject')(this._reason) break default: break &#125; return promise&#125; 注意：_resolveCallback与_rejectCallback的回调函数中的promise实例是当前then返回的promise，这样才能实现链式调用，每次then方法返回一个新的Promise，根据上一个Promise执行状态执行对应的回调。这样也解决了上面角标[2]的问题，每个then函数都依赖于上一个then方法的执行结果。 同时，上面提出的问题，then函数返回promise实例其实可以改变下一个promise实例的处理状态，而resolve参数为promise则决定了当前promise的状态 总结promise的实现包含了很多细节性问题，需要慢慢推敲实现，并且规范中并未描述具体的api实现细节，所以需要查看ecma规范。 对于api并未做详细的讲解，其实catch方法就是then(null, onRejected)，Promise.all()等api实现起来也不太复杂。具体api的实现可以查看我的promise实现：https://github.com/fengdonglp/fd-promise 参考 Promises/A+规范(中文版) Promises/A+规范(英文版) JS Promise的实现原理]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native开发中遇到的坑]]></title>
    <url>%2F2018%2F04%2F08%2Freact-native-pit%2F</url>
    <content type="text"><![CDATA[样式的坑 1、 无 border: none 样式属性；2、 StyleSheet.create() 创建了一个样式，在组件上使用时仅仅引用了一个id，所以如果你打印styles.name,则会返回一个数字id; 创建一个样式表，就可以使得我们后续更容易通过ID来引用样式，而不是每次都创建一个新的对象。 它还使得样式只会在JavaScript和原生之间传递一次，随后的过程都可以只传递一个ID（这个优化还未实现）。 密钥库文件问题 在使用react-native-amap3d组件时，需要注册高德key,出现以下问题： [keytool 错误: java.lang.Exception: 密钥库文件不存在: keystore] 参考地址：https://blog.csdn.net/Newsolider2012/article/details/52401735 第一步、生成keystore文件 keytool属于java jdk的一个工具，我们可以利用这个去生成密钥文件； 打开cmd, 使用命令cd 你的java安装目录/java/jdk/bin,进入keytool可执行文件的路径； 执行keytool -genkey -alias key文件别名 -keyalg RSA -validity 20000 -keystore geom.keystore，会出现接下来的界面：在bin目录下会生成对应的.keystore文件，此文件就是你的签名文件； 第二步、在项目中应用keystore 打开你的Android项目的build.gradle，将keystore文件绑定到项目中：123456789101112131415161718android &#123; compileSdkVersion 23 buildToolsVersion "23.0.1" signingConfigs &#123; release &#123; keyAlias 'geom' keyPassword 'lfreformer' storeFile file('E:/GeomDebug/android/keystores/geom.keystore') storePassword 'lfreformer' &#125; debug &#123; keyAlias 'geom' keyPassword 'lfreformer' storeFile file('E:/GeomDebug/android/keystores/geom.keystore') storePassword 'lfreformer' &#125; &#125;&#125; 第三步、获取KeyStore指纹信息 打开Android studio 的控制台；执行命令：keytool -list -v -keystore E:\GeomDebug\android\keystores\geom.keystore(这儿需要你替换成自己的keystore文件路径)注意：最后是你keystore文件存放位置；最后获取结果：其中SHA1值就是需要的在高德地图中填写的内容。 模拟数据 由于项目开发过程中前端独立开发阶段需要自己模拟本地数据，所以就引出一个问题，react-native的模拟数据放置在哪，如何请求。其实react-native启动时会在项目根目录默认开一个端口号为8081的server，所以只需将mock数据放置在项目根目录进行请求即可。我的模拟数据目录：请求示例：1fetch('http://localhost:8081/mock/xx.json').then(...) Api方式动态添加元素 参考：react-native-root-siblings 在开发过程中会遇到自定义toast，alert等需要通过api方式（eg: Toast.show()）全局显示的组件，这个时候要动态添加组件，并且必须是全局组件的属性，在react-native中如何实现，这个时候需要用到AppRegistry的setWrapperComponentProvider方法：1234567891011121314151617181920212223242526272829import React, &#123; Component &#125; from 'react';import &#123; View, Text, AppRegistry &#125; from 'react-native';AppRegistry.setWrapperComponentProvider(function() &#123; return class extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;View style=&#123;&#123;flex: 1&#125;&#125;&gt; &#123;this.props.children&#125; &lt;View style=&#123;&#123; width: 200, height: 500, backgroundColor: 'red', position: 'absolute', zIndex: 1000, top: 45, left: 0 &#125;&#125; /&gt; &lt;/View&gt; ) &#125; &#125;&#125;) 注意： AppRegistry.setWrapperComponentProvider 不可用在组件生命周期内，必须全局/模块中使用； return的组件中必须包裹{this.props.children}，这个子组件代表你每页的组件，而内部包含的View组件就是你动态添加的组件； Android端双击物理返回键退出应用 api: BackHandler; 示例：1234567891011121314151617181920212223242526272829303132333435export default function (WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this._onBackAndroid = this._onBackAndroid.bind(this); &#125; componentWillMount()&#123; BackHandler.addEventListener('hardwareBackPress', this._onBackAndroid); &#125; componentWillUnmount() &#123; BackHandler.removeEventListener('hardwareBackPress', this._onBackAndroid); &#125; render() &#123; return ( &lt;WrappedComponent &#123;...this.props&#125; backHandler=&#123;this._onBackAndroid&#125; /&gt; ) &#125; _onBackAndroid() &#123; if (this.lastBackPressed &amp;&amp; this.lastBackPressed + 2000 &gt;= Date.now()) &#123; //最近2秒内按过back键，可以退出应用。 return false; &#125; this.lastBackPressed = Date.now(); ToastAndroid.show('再按一次退出应用', ToastAndroid.SHORT); return true; &#125; &#125;&#125; 示例为react高阶函数组件，可包裹用于任意组件；存在问题：首页组件不会触发componentWillUnmount生命周期，所以会导致在首页后打开的任意页面物理返回键均会触发“再按一次退出应用”，在react-navigation中，修改为如下方式：12345678910111213141516171819202122232425262728293031323334componentDidMount() &#123; this.getParkData(); this.didFocusSubscription = this.props.navigation.addListener( 'didFocus', payload =&gt; &#123; BackHandler.addEventListener('hardwareBackPress', this.props.backHandler); this.getStorage().then(data =&gt; &#123; if (data) &#123; data = JSON.parse(data); AsyncStorage.removeItem('selectPark'); this.locate(data, this.showInfoWindow.bind(this, data)); &#125; &#125;) &#125; ); this.willBlurSubscription = this.props.navigation.addListener( 'willBlur', payload =&gt; &#123; BackHandler.removeEventListener('hardwareBackPress', this.props.backHandler); &#125; );&#125;componentWillUnmount() &#123; if (this.didFocusSubscription) &#123; this.didFocusSubscription.remove(); &#125; if (this.willBlurSubscription) &#123; this.willBlurSubscription.remove(); &#125;&#125; 以上通过监听react-navigation提供的事件进行BackHandler的处理; 修改打包后应用名 默认应用名会是应用初始化时的文件名；修改方式： 进入android/app/src/main/AndroidManifest.xml; 找到android:label=&quot;@string/app_name&quot;，这个就代表的是应用名(引用第三步文件内的值)； 进入android/app/src/main/res/valuse/strings.xml； 修改如下代码：123&lt;resources&gt; &lt;string name="app_name"&gt;你的APP名称&lt;/string&gt;&lt;/resources&gt;]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli源码分析]]></title>
    <url>%2F2018%2F04%2F07%2FVue-cli-source-code-analysis%2F</url>
    <content type="text"><![CDATA[vue-cli源码分析—— 一步步实现自己的脚手架工具 基于版本2.9.3， vue-cli 3.x更改为与create-react-app类似的集成cli了，所以待有时间再研究 工作流程根据自己的理解绘制流程图： 第三方依赖 download-git-repo从git仓库下载项目模板 commander组织和处理命令行工具，简化命令流程 metalsmith静态站点生成工具，插件化文件处理流程，插件化类似于express的中间件 inquirer实现交互式命令行 handlebars模板渲染引擎 async异步执行管理函数 ora在终端优雅地显示进度工具 user-homeNode4.x之前没有获取用户目录的api，所以这个是用来兼容之前的，其实也可以不需要，因为node版本现在都已经很高了，用require(&quot;os&quot;).homedir()代替 tildify将绝对路径转换为波浪路径，e.g. /Users/sindresorhus/dev -&gt; ~/dev chalk在终端打印出带有颜色的文字 rimraf实现unix command rm -rf semvernpm语义版本，可用于比较、验证版本号 request简单的http请求，用于vue list 获取所有版本 multimatch扩展自minimatch.match()，可匹配多个模式 如何让发布的npm包全局可执行让你的npm包实现像vue-cli一样，全局执行vue命令，其实非常简单；下面简单实现一个小demo: 第一步 新建项目，初始化项目，编写的执行程序文件，存放为 项目根目录/bin/test，注意文件名没有后缀。12#!/usr/bin/env nodeconsole.log('test'); 第二步 添加npm bin配置12345&#123; "bin": &#123; "test": "./bin/test" &#125;&#125; 第三步 link当前模块为全局模块 项目根目录执行以下命令1$ npm link 实际开发时，将项目publish到npm包时，不需要该命令，这个只是为测试，将当前模块link为全局模块后，可执行全局test命令,现在在终端执行test会打印出test，证明成功了。 现在再去看源码时，就可以直接看vue-cli bin目录下的vue文件了。 ——————–分割线—————————- 补充知识 npm包实现可执行命令的探究 windows上如果要让一个文件可执行，那么这个文件应该是.exe或者.cmd后缀，或者通过程序运行,比如：node test.js; linux上不根据扩展名来判断文件是否可执行，大家一定注意到上面的test.js文件第一行#!/usr/bin/env node，其实这个就是用来表明该文件可以在linux下执行，并且指明用node程序执行。 那么为什么在项目package.json文件加上bin属性就可以变为可执行？ 如何查看可执行文件存在位置 在命令行执行npm bin -g即可查找到，比如我执行后的结果： windows因为在全局安装包时，npm会判断package.json是否有bin配置，如果存在，则会在npm包的环境变量设置目录下新建xxx.cmd文件和一个xxx文件（shell可执行文件，第一行为：#!/bin/sh），xxx就是在bin属性下配置的属性值，比如上面例子中写的是test文件，可执行文件名就会是test，test.cmd文件内容如下： 1234567@IF EXIST "%~dp0\node.exe" ( "%~dp0\node.exe" "%~dp0\node_modules\test-cli\bin\test" %*) ELSE ( @SETLOCAL @SET PATHEXT=%PATHEXT:;.JS;=;% node "%~dp0\node_modules\test-cli\bin\test" %*) %~dp0在windows中代表该bat脚本文件所在目录路径，该程序意思就是查看当前目录下是否有node程序；如果有，则直接用当前目录下的node程序执行test文件；如果不存在，直接全局调用。 linux在linux上因为test文件本身就是可执行的，所以与window上不同的是，npm会在linux的.nvm/versions/node/v9.11.1/bin目录下新建一个软连接，指向安装目录下的bin目录下的可执行文件： 图片以pm2的软连接为例子。 介绍几个重要的第三方依赖库1. commander简化命令行操作，具体使用方法这里不做介绍，官网的解释已经很全面了。commander有两种使用方式： 第一种，action形式,如果匹配到对应的command就会执行对应的action 修改test文件为下面的内容：12345678910111213#!/usr/bin/env nodeconst program = require('commander');program .command('init &lt;dir&gt;') .option('-c --clone', 'download template through git-clone') .action((dir, cmd) =&gt; &#123; console.log(dir); console.log(cmd.clone); &#125;);program.parse(process.argv); 执行test init /temp -c，打印结果： 第二种，git-style 模式，可以将子命令分成模块 vue-cli采取的就是这种模式。现在修改test:123456program .version(require('../package.json').version) .usage('&lt;command&gt; [options]') .command('init', '生成一个新项目');program.parse(process.argv); 增加test-init文件：123456789101112131415161718#!/usr/bin/env nodeconst program = require('commander');program .usage('&lt;template-name&gt; [project-name]') .option('-c --clone', 'use git-clone');/** * 确保在命令行运行 test init 无参数时显示该命令的help提示 * help指令是commander自动生成的，如果想自定义，可以查看vue-cli源码35-44行 */function help () &#123; program.parse(process.argv); if (program.args.length &lt; 1) return program.help();&#125;help(); 执行test init： 可以看到执行了test-init文件，这就是commander的sub-commander形式，test文件定义了都有什么命令（注意不可以有action），当匹配到相应的命令，但是没有匹配到action时就会去找当前文件下的test-命令文件。 2. download-git-repo 支持的远程仓库：github、gitlab、bitbucket、自定义仓库 该模块整合了git-clone和download，同时支持执行git clone命令和http协议下载两种方式。 有了这个模块我们就可以从远程下载我们提前做好的项目模板了。 使用方法：require(&#39;download-git-repo&#39;)(url, dest, option, callback) url：下载路径格式： owner/name#my-branch e.g. vuejs-templates/webpack默认github仓库，如果要下在其他的，格式： gitlab:owner/name#my-branch，自定义仓库：https://mygitlab.com:owner/name#my-branch dest：下载至dest目录 option: clone 为true时，使用git clone下载，否则使用http download callback: 回调 现在，修改我们的test-init 文件： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env nodeconst program = require('commander');const path = require('path');const gitDownload = require('download-git-repo');program .usage('&lt;template-name&gt; [project-name]') .option('-c --clone', 'use git-clone');/** * 确保在命令行运行 test init 无参数时显示该命令的help提示 * help指令是commander自动生成的，如果想自定义，可以查看vue-cli源码35-44行 */function help () &#123; program.parse(process.argv); if (program.args.length &lt; 1) return program.help();&#125;help();let template = program.args[0];const desc = path.join(__dirname, '../', '.vue-template/', template);gitDownload( template, // 这里可以仿照vue-cli，将模板存储在硬盘根目录下，用于下次新建项目时，可以离线使用 // 我这里因为本地已经有了，所以下载在项目文件下，方便测试 desc, &#123; clone: program.clone &#125;, err =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log('下载完成'); &#125; &#125;) 这里，因为还没又自己的模板，我们用vue-cli的模板进行测试，执行test init vuejs-templates/webpack test-vue，等待一会回发现控制台打印出下载完成。 根据以上几个步骤，如果没有模板渲染的需求，基本上就可以创作出最简版的cli工具了，但是工作中会遇到每个项目不同使用的编译环境或者依赖都不同，所以需要进一步通过命令行交互实现同一个模板用于不同项目。 补充 在看vue-cli的源码的时候，会发现vue-cli也提供了–clone的选项，但是如果我们在用vue的模板时加上–clone选项，会发现出现了报错: 主要原因：vuejs-templates/webpack的默认分支并不是master而是develop，这里需要查看download-git-repo的源码12345678910// line 32-39// repo.checkout默认为master，所以shallow默认为truegitclone(url, dest, &#123; checkout: repo.checkout, shallow: repo.checkout === 'master' &#125;, function (err) &#123; if (err === undefined) &#123; rm(dest + '/.git') fn() &#125; else &#123; fn(err) &#125; &#125;) 进一步需要看下git-clone的源码，会发现当checkout有值时，会进行git checkout操作，并且shallow为true时，git clone 会添加–depth 1。 现在明白了，由于shallow为true，导致git clone 时只下载了最近一次commit，并且仅包含默认分支，而vuejs-templates/webpack的默认分支不是master，所以git-clone模块进行git checkout master报错。 这里，如果我们在下载自己的模板并且添加了–clone参数时需确保模板默认分支为master，当然，也可以自己写一个模块 inquirer具体api请自行查阅官方文档，这里简单应用到我们自建的项目中 metalsmith]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
        <tag>javascript</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chalk.js源码分析]]></title>
    <url>%2F2018%2F04%2F06%2Fchalk%2F</url>
    <content type="text"><![CDATA[nodejs如何在终端输出带颜色的命令行 参考：colors源码ansi-styles源码chalk源码ANSI转义字符通过控制台输出各种颜色的字符——ANSIConsole、JANSI知乎 ~ Node.js Color 模块实现入门浅析 已有实现方案colors、chalk、cli-color等 ANSI控制码（ANSI escape code）ANSI 具体介绍可查看维基百科)的解释。 如果要实现控制终端输出文字颜色或者背景色等，首先需要了解ANSI控制码。 ANSI控制码用于在字符显示系统中控制光标移动和字符色彩等，常用于BBS系统中。 ANSI ESCAPE SEQUENCES又称为VT100系列控制码，国内译为ANSI控制码。顾名思义，需要VT100系列终端的支持，当然现在已经不在局限于VT100了，包括xterm,linux都能很好完成。 ANSI控制码开始的标志都为ESC[，ESC对应ASCII码表的033(八进制)，linux命令echo用-e启用转义，\033来输入ESC，\033[31m即为ESC[31m。 但是，通常在使用时通常用十六进制来表示ESC，即\u001b。 注意：不同的终端对ANSI控制码的支持度不一样，所以不能保证所有系统上都可以实现效果。 ASCII控制字符 二进制 十进制 十六进制 缩写 可以显示的表示法 名称/意义 0000 0000 0 00 NUL ␀ 空字符（Null） 0000 0001 1 01 SOH ␁ 标题开始 0000 0010 2 02 STX ␂ 本文开始 0000 0011 3 03 ETX ␃ 本文结束 0000 0100 4 04 EOT ␄ 传输结束 0000 0101 5 05 ENQ ␅ 请求 0000 0110 6 06 ACK ␆ 确认回应 0000 0111 7 07 BEL ␇ 响铃 0000 1000 8 08 BS ␈ 退格 0000 1001 9 09 HT ␉ 水平定位符号 0000 1010 10 0A LF ␊ 换行键 0000 1011 11 0B VT ␋ 垂直定位符号 0000 1100 12 0C FF ␌ 换页键 0000 1101 13 0D CR ␍ 归位键 0000 1110 14 0E SO ␎ 取消变换（Shift out） 0000 1111 15 0F SI ␏ 启用变换（Shift in） 0001 0000 16 10 DLE ␐ 跳出数据通讯 0001 0001 17 11 DC1 ␑ 设备控制一（XON 启用软件速度控制） 0001 0010 18 12 DC2 ␒ 设备控制二 0001 0011 19 13 DC3 ␓ 设备控制三（XOFF 停用软件速度控制） 0001 0100 20 14 DC4 ␔ 设备控制四 0001 0101 21 15 NAK ␕ 确认失败回应 0001 0110 22 16 SYN ␖ 同步用暂停 0001 0111 23 17 ETB ␗ 区块传输结束 0001 1000 24 18 CAN ␘ 取消 0001 1001 25 19 EM ␙ 连接介质中断 0001 1010 26 1A SUB ␚ 替换 0001 1011 27 1B ESC ␛ 跳出 0001 1100 28 1C FS ␜ 文件分割符 0001 1101 29 1D GS ␝ 组群分隔符 0001 1110 30 1E RS ␞ 记录分隔符 0001 1111 31 1F US ␟ 单元分隔符 0111 1111 127 7F DEL ␡ 删除 通过阅读下面的文章可以知道，其实就是通过控制码进行样式渲染。 可参阅: 通过Ansi Escape Codes酷炫玩转命令行！原文地址：http://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html 编码延伸阅读 阮一峰 ~ 字符编码笔记：ASCII，Unicode 和 UTF-8 各种编码UNICODE、UTF-8、ANSI、ASCII、GB2312、GBK详解 字符编码的那些事 知乎 ~ Unicode 和 UTF-8 有何区别？ chalk源码分析 版本：2.4.1 为什么要解读chalk，通过查看上面介绍的几个实现方案，chalk是有对ansi颜色输出支持的判断，所以兼容性处理更好。 chalk包含了几个重要依赖： escape-string-regexp — 字符串转义功能对特殊字符进行转义，e.g. ‘$’ =&gt; ‘\$’ supports-color — 判断当前系统终端支持的颜色（8色、16色、256色） ansi-styles — ANSI控制码对应的颜色值 先对chalk的整体架构进行了整理，源码很少，但是涉及到原型的东西蛮多的，容易弄混，所以整理成图： 现在分析下源码： 1. module.exports1234// 实际输出的是chalk.template,看第2点module.exports = Chalk(); // eslint-disable-line new-capmodule.exports.supportsColor = stdoutColor;module.exports.default = module.exports; // For TypeScript 2. Chalk定义123456789101112131415161718192021222324252627// 定义Chalk, 生成chalk与chalk.template// 定义原型指向，如上图左侧部分function Chalk(options) &#123; // We check for this.template here since calling `chalk.constructor()` // by itself will have a `this` of a previously constructed chalk object if (!this || !(this instanceof Chalk) || this.template) &#123; const chalk = &#123;&#125;; applyOptions(chalk, options); chalk.template = function () &#123; const args = [].slice.call(arguments); return chalkTag.apply(null, [chalk.template].concat(args)); &#125;; // 修改原型指向 Object.setPrototypeOf(chalk, Chalk.prototype); Object.setPrototypeOf(chalk.template, chalk); // 定义constructor，用于生成新的Chalk实例 // e.g. const ctx = new chalk.constructor(&#123;enabled: false&#125;); chalk.template.constructor = Chalk; return chalk.template; &#125; applyOptions(this, options);&#125; 3. stylesstyles可以说是所有使用方法的集合，因为所有的使用方法都是通过Object.defineProperties(xxx, styles)生成的。 styles到底长什么样呢？12345678910111213141516171819202122// styles结构示例&#123; red: &#123; get() &#123; return build.call(...); &#125; &#125;, black: &#123; get() &#123; return build.call(...); &#125; &#125;, // 颜色转换方法与直接取颜色值使用方法不同，结构也有所差异 ansi: &#123; get() &#123; return function() &#123; return build.call(...); &#125; &#125; &#125; ...&#125; 下图是在vsCode中断点截取的styles的构造 我们在使用chalk时的一个例子就是console.log(clalk.red(&#39;Hello&#39;)),通过上面的原型结构我们知道chalk.red其实就是调用了Chalk.prototype.red,那具体做了什么呢，接着看源码第224行：1Object.defineProperties(Chalk.prototype, styles); 其实为了将styles的所有方法实现在原型上，所以作者才用get(){}属性的，如果不懂的话去查defineProperties方法。 4.styles由来从源码55 ~ 115行，可以看出，ansi-styles模块就是其由来（也就是源码开头定义的ansiStyles）。这个模块定义了每个颜色对应的ANSI控制码,并从color-convert模块生成了一系列颜色转换工具函数，也就是chalk中的hex()、rbg()等方法的由来； 123456789101112131415161718192021222324// ansiStyles结构&#123; // 颜色 bgBlack: &#123; open: '\u001b[40m', close: '\u001b[49m', closeRe: /\\u001b\[49m/g // 这个是chalk源码94行添加的，不属于ansi-styles模块自有 &#125;, ... // color模块 指ANSI控制码 31-37 color: &#123; ... &#125;, // bgColor模块 指ANSI控制码 40-47 bgColor: &#123; ... &#125;, // modifier模块 指ANSI控制码 0-8 modifier: &#123; bold: &#123; ... &#125;, ... &#125; 6. 链式操作的实现console.log(chalk.red.underline(&#39;Hello&#39;))这种操作是如何实现的呢可以看下最初的图，其实里面已经描述的很清楚了，下面从源码讲解下：123456789101112131415161718192021222324252627282930313233// 1. styles每个方法的定义styles[key] = &#123; get() &#123; const codes = ansiStyles[key]; // 每个方法其实都返回了build函数的执行结果，即builder return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key); &#125;&#125;;// 2. 定义builder的原型const proto = Object.defineProperties(() =&gt; &#123;&#125;, styles);function build(_styles, _empty, key) &#123; const builder = function () &#123; return applyStyle.apply(builder, arguments); &#125;; ... // `__proto__` is used because we must return a function, but there is // no way to create a function with a different prototype // builder的原型指向为proto builder.__proto__ = proto; // eslint-disable-line no-proto return builder;&#125;// 3. 生成Chalk原型// 可以看出proto和Chalk其实一模一样Object.defineProperties(Chalk.prototype, styles);// 总结// 因为每个builder方法原型都指向了proto，proto中的方法又都是builder函数，即原型又指向proto,构成无限循环,所以可以无限链式调用chalk.red.underline -&gt; Chalk.prototype.red -&gt; builder方法(即red方法) -&gt; builder原型指向proto -&gt; builder.__proto__.underline 7. 返回最终调用返回结果就是返回了一个包含ANSI控制码的字符串e.g. &quot;\u001b[31m\u001b[4m Hello \u001b[24m\u001b[39m&quot;(红色带下划线) 其实就是在每次调用后再this._styles结构中增加了每种修饰的open与close]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm注册账户报错400]]></title>
    <url>%2F2017%2F04%2F08%2Fnpm-register-error%2F</url>
    <content type="text"><![CDATA[npm注册 npm发布包时必须得有npm账户才能进行包的发布工作，所以进行注册账户，有两种方式： 在官网进行注册，npm注册地址 命令行1234567#请注意必须安装npm,执行以下命令，按提示操作即可$ npm adduserUsername:Password：Email: (this IS public)#如果出现下面语句则代表成功Logged in as &#123;你刚才注册的用户名&#125; on https://registry.npmjs.org/. 注册npm账户时出现错误 错误信息如下：12345npm ERR! code E400npm ERR! Registry returned 400 for PUT on https://registry.npmjs.org/-/user/org.couchdb.user:fengdong: That email has already been registered.npm ERR! A complete log of this run can be found in:npm ERR! D:\nodejs\node_cache\_logs\2018-05-15T07_13_47_400Z-debug.log 一开始，以为是以下问题： 账号重复 密码过于简单 邮箱重复 但是经过尝试，并在npm官网验证都不是；抱着试一试的态度重新注册，用户名全新并且很长，密码很复杂，邮箱采用qq邮箱，居然成功了。。。。WTF 前后比对，之前都是用163邮箱进行注册的，更换qq邮箱居然成功，遂更换为微软的outlook邮箱，成功。 总结：不能用163邮箱进行npm注册(原因未知)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>error</tag>
      </tags>
  </entry>
</search>
