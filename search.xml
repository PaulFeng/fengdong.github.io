<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue-cli源码分析]]></title>
    <url>%2F2018%2F04%2F07%2FVue-cli-source-code-analysis%2F</url>
    <content type="text"><![CDATA[vue-cli源码分析—— 一步步实现自己的脚手架工具 基于版本2.9.3， vue-cli 3.x更改为与create-react-app类似的集成cli了，所以待有时间再研究 工作流程根据自己的理解绘制流程图： 第三方依赖 download-git-repo从git仓库下载项目模板 commander组织和处理命令行工具，简化命令流程 metalsmith静态站点生成工具，插件化文件处理流程，插件化类似于express的中间件 inquirer实现交互式命令行 handlebars模板渲染引擎 async异步执行管理函数 ora在终端优雅地显示进度工具 user-homeNode4.x之前没有获取用户目录的api，所以这个是用来兼容之前的，其实也可以不需要，因为node版本现在都已经很高了，用require(&quot;os&quot;).homedir()代替 tildify将绝对路径转换为波浪路径，e.g. /Users/sindresorhus/dev -&gt; ~/dev chalk在终端打印出带有颜色的文字 rimraf实现unix command rm -rf semvernpm语义版本，可用于比较、验证版本号 request简单的http请求，用于vue list 获取所有版本 multimatch扩展自minimatch.match()，可匹配多个模式 如何让发布的npm包全局可执行让你的npm包实现像vue-cli一样，全局执行vue命令，其实非常简单；下面简单实现一个小demo: 第一步 新建项目，初始化项目，编写的执行程序文件，存放为 项目根目录/bin/test，注意文件名没有后缀。12#!/usr/bin/env nodeconsole.log('test'); 第二步 添加npm bin配置12345&#123; "bin": &#123; "test": "./bin/test" &#125;&#125; 第三步 link当前模块为全局模块 项目根目录执行以下命令1$ npm link 实际开发时，将项目publish到npm包时，不需要该命令，这个只是为测试，将当前模块link为全局模块后，可执行全局test命令,现在在终端执行test会打印出test，证明成功了。 现在再去看源码时，就可以直接看vue-cli bin目录下的vue文件了。 ——————–分割线—————————- 补充知识 npm包实现可执行命令的探究 windows上如果要让一个文件可执行，那么这个文件应该是.exe或者.cmd后缀，或者通过程序运行,比如：node test.js; linux上不根据扩展名来判断文件是否可执行，大家一定注意到上面的test.js文件第一行#!/usr/bin/env node，其实这个就是用来表明该文件可以在linux下执行，并且指明用node程序执行。 那么为什么在项目package.json文件加上bin属性就可以变为可执行？ 如何查看可执行文件存在位置 在命令行执行npm bin -g即可查找到，比如我执行后的结果： windows因为在全局安装包时，npm会判断package.json是否有bin配置，如果存在，则会在npm包的环境变量设置目录下新建xxx.cmd文件和一个xxx文件（shell可执行文件，第一行为：#!/bin/sh），xxx就是在bin属性下配置的属性值，比如上面例子中写的是test文件，可执行文件名就会是test，test.cmd文件内容如下： 1234567@IF EXIST "%~dp0\node.exe" ( "%~dp0\node.exe" "%~dp0\node_modules\test-cli\bin\test" %*) ELSE ( @SETLOCAL @SET PATHEXT=%PATHEXT:;.JS;=;% node "%~dp0\node_modules\test-cli\bin\test" %*) %~dp0在windows中代表该bat脚本文件所在目录路径，该程序意思就是查看当前目录下是否有node程序；如果有，则直接用当前目录下的node程序执行test文件；如果不存在，直接全局调用。 linux在linux上因为test文件本身就是可执行的，所以与window上不同的是，npm会在linux的.nvm/versions/node/v9.11.1/bin目录下新建一个软连接，指向安装目录下的bin目录下的可执行文件： 图片以pm2的软连接为例子。 介绍几个重要的第三方依赖库1. commander简化命令行操作，具体使用方法这里不做介绍，官网的解释已经很全面了。commander有两种使用方式： 第一种，action形式,如果匹配到对应的command就会执行对应的action 修改test文件为下面的内容：12345678910111213#!/usr/bin/env nodeconst program = require('commander');program .command('init &lt;dir&gt;') .option('-c --clone', 'download template through git-clone') .action((dir, cmd) =&gt; &#123; console.log(dir); console.log(cmd.clone); &#125;);program.parse(process.argv); 执行test init /temp -c，打印结果： 第二种，git-style 模式，可以将子命令分成模块 vue-cli采取的就是这种模式。现在修改test:123456program .version(require('../package.json').version) .usage('&lt;command&gt; [options]') .command('init', '生成一个新项目');program.parse(process.argv); 增加test-init文件：123456789101112131415161718#!/usr/bin/env nodeconst program = require('commander');program .usage('&lt;template-name&gt; [project-name]') .option('-c --clone', 'use git-clone');/** * 确保在命令行运行 test init 无参数时显示该命令的help提示 * help指令是commander自动生成的，如果想自定义，可以查看vue-cli源码35-44行 */function help () &#123; program.parse(process.argv); if (program.args.length &lt; 1) return program.help();&#125;help(); 执行test init： 可以看到执行了test-init文件，这就是commander的sub-commander形式，test文件定义了都有什么命令（注意不可以有action），当匹配到相应的命令，但是没有匹配到action时就会去找当前文件下的test-命令文件。 2. download-git-repo 支持的远程仓库：github、gitlab、bitbucket、自定义仓库 该模块整合了git-clone和download，同时支持执行git clone命令和http协议下载两种方式。 有了这个模块我们就可以从远程下载我们提前做好的项目模板了。 使用方法：require(&#39;download-git-repo&#39;)(url, dest, option, callback) url：下载路径格式： owner/name#my-branch e.g. vuejs-templates/webpack默认github仓库，如果要下在其他的，格式： gitlab:owner/name#my-branch，自定义仓库：https://mygitlab.com:owner/name#my-branch dest：下载至dest目录 option: clone 为true时，使用git clone下载，否则使用http download callback: 回调 现在，修改我们的test-init 文件： 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env nodeconst program = require('commander');const path = require('path');const gitDownload = require('download-git-repo');program .usage('&lt;template-name&gt; [project-name]') .option('-c --clone', 'use git-clone');/** * 确保在命令行运行 test init 无参数时显示该命令的help提示 * help指令是commander自动生成的，如果想自定义，可以查看vue-cli源码35-44行 */function help () &#123; program.parse(process.argv); if (program.args.length &lt; 1) return program.help();&#125;help();let template = program.args[0];const desc = path.join(__dirname, '../', '.vue-template/', template);gitDownload( template, // 这里可以仿照vue-cli，将模板存储在硬盘根目录下，用于下次新建项目时，可以离线使用 // 我这里因为本地已经有了，所以下载在项目文件下，方便测试 desc, &#123; clone: program.clone &#125;, err =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log('下载完成'); &#125; &#125;) 这里，因为还没又自己的模板，我们用vue-cli的模板进行测试，执行test init vuejs-templates/webpack test-vue，等待一会回发现控制台打印出下载完成。 根据以上几个步骤，如果没有模板渲染的需求，基本上就可以创作出最简版的cli工具了，但是工作中会遇到每个项目不同使用的编译环境或者依赖都不同，所以需要进一步通过命令行交互实现同一个模板用于不同项目。 补充 在看vue-cli的源码的时候，会发现vue-cli也提供了–clone的选项，但是如果我们在用vue的模板时加上–clone选项，会发现出现了报错: 主要原因：vuejs-templates/webpack的默认分支并不是master而是develop，这里需要查看download-git-repo的源码12345678910// line 32-39// repo.checkout默认为master，所以shallow默认为truegitclone(url, dest, &#123; checkout: repo.checkout, shallow: repo.checkout === 'master' &#125;, function (err) &#123; if (err === undefined) &#123; rm(dest + '/.git') fn() &#125; else &#123; fn(err) &#125; &#125;) 进一步需要看下git-clone的源码，会发现当checkout有值时，会进行git checkout操作，并且shallow为true时，git clone 会添加–depth 1。 现在明白了，由于shallow为true，导致git clone 时只下载了最近一次commit，并且仅包含默认分支，而vuejs-templates/webpack的默认分支不是master，所以git-clone模块进行git checkout master报错。 这里，如果我们在下载自己的模板并且添加了–clone参数时需确保模板默认分支为master，当然，也可以自己写一个模块 inquirer具体api请自行查阅官方文档，这里简单应用到我们自建的项目中 metalsmith]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>vue-cli</tag>
        <tag>javascript</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chalk.js源码分析]]></title>
    <url>%2F2018%2F04%2F06%2Fchalk%2F</url>
    <content type="text"><![CDATA[nodejs如何在终端输出带颜色的命令行 参考：colors源码ansi-styles源码chalk源码ANSI转义字符通过控制台输出各种颜色的字符——ANSIConsole、JANSI知乎 ~ Node.js Color 模块实现入门浅析 已有实现方案colors、chalk、cli-color等 ANSI控制码（ANSI escape code）ANSI 具体介绍可查看维基百科)的解释。 如果要实现控制终端输出文字颜色或者背景色等，首先需要了解ANSI控制码。 ANSI控制码用于在字符显示系统中控制光标移动和字符色彩等，常用于BBS系统中。 ANSI ESCAPE SEQUENCES又称为VT100系列控制码，国内译为ANSI控制码。顾名思义，需要VT100系列终端的支持，当然现在已经不在局限于VT100了，包括xterm,linux都能很好完成。 ANSI控制码开始的标志都为ESC[，ESC对应ASCII码表的033(八进制)，linux命令echo用-e启用转义，\033来输入ESC，\033[31m即为ESC[31m。 但是，通常在使用时通常用十六进制来表示ESC，即\u001b。 注意：不同的终端对ANSI控制码的支持度不一样，所以不能保证所有系统上都可以实现效果。 ASCII控制字符 二进制 十进制 十六进制 缩写 可以显示的表示法 名称/意义 0000 0000 0 00 NUL ␀ 空字符（Null） 0000 0001 1 01 SOH ␁ 标题开始 0000 0010 2 02 STX ␂ 本文开始 0000 0011 3 03 ETX ␃ 本文结束 0000 0100 4 04 EOT ␄ 传输结束 0000 0101 5 05 ENQ ␅ 请求 0000 0110 6 06 ACK ␆ 确认回应 0000 0111 7 07 BEL ␇ 响铃 0000 1000 8 08 BS ␈ 退格 0000 1001 9 09 HT ␉ 水平定位符号 0000 1010 10 0A LF ␊ 换行键 0000 1011 11 0B VT ␋ 垂直定位符号 0000 1100 12 0C FF ␌ 换页键 0000 1101 13 0D CR ␍ 归位键 0000 1110 14 0E SO ␎ 取消变换（Shift out） 0000 1111 15 0F SI ␏ 启用变换（Shift in） 0001 0000 16 10 DLE ␐ 跳出数据通讯 0001 0001 17 11 DC1 ␑ 设备控制一（XON 启用软件速度控制） 0001 0010 18 12 DC2 ␒ 设备控制二 0001 0011 19 13 DC3 ␓ 设备控制三（XOFF 停用软件速度控制） 0001 0100 20 14 DC4 ␔ 设备控制四 0001 0101 21 15 NAK ␕ 确认失败回应 0001 0110 22 16 SYN ␖ 同步用暂停 0001 0111 23 17 ETB ␗ 区块传输结束 0001 1000 24 18 CAN ␘ 取消 0001 1001 25 19 EM ␙ 连接介质中断 0001 1010 26 1A SUB ␚ 替换 0001 1011 27 1B ESC ␛ 跳出 0001 1100 28 1C FS ␜ 文件分割符 0001 1101 29 1D GS ␝ 组群分隔符 0001 1110 30 1E RS ␞ 记录分隔符 0001 1111 31 1F US ␟ 单元分隔符 0111 1111 127 7F DEL ␡ 删除 通过阅读下面的文章可以知道，其实就是通过控制码进行样式渲染。 可参阅: 通过Ansi Escape Codes酷炫玩转命令行！原文地址：http://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html 编码延伸阅读 阮一峰 ~ 字符编码笔记：ASCII，Unicode 和 UTF-8 各种编码UNICODE、UTF-8、ANSI、ASCII、GB2312、GBK详解 字符编码的那些事 知乎 ~ Unicode 和 UTF-8 有何区别？ chalk源码分析 版本：2.4.1 为什么要解读chalk，通过查看上面介绍的几个实现方案，chalk是有对ansi颜色输出支持的判断，所以兼容性处理更好。 chalk包含了几个重要依赖： escape-string-regexp — 字符串转义功能对特殊字符进行转义，e.g. ‘$’ =&gt; ‘\$’ supports-color — 判断当前系统终端支持的颜色（8色、16色、256色） ansi-styles — ANSI控制码对应的颜色值 先对chalk的整体架构进行了整理，源码很少，但是涉及到原型的东西蛮多的，容易弄混，所以整理成图： 现在分析下源码： 1. module.exports1234// 实际输出的是chalk.template,看第2点module.exports = Chalk(); // eslint-disable-line new-capmodule.exports.supportsColor = stdoutColor;module.exports.default = module.exports; // For TypeScript 2. Chalk定义123456789101112131415161718192021222324252627// 定义Chalk, 生成chalk与chalk.template// 定义原型指向，如上图左侧部分function Chalk(options) &#123; // We check for this.template here since calling `chalk.constructor()` // by itself will have a `this` of a previously constructed chalk object if (!this || !(this instanceof Chalk) || this.template) &#123; const chalk = &#123;&#125;; applyOptions(chalk, options); chalk.template = function () &#123; const args = [].slice.call(arguments); return chalkTag.apply(null, [chalk.template].concat(args)); &#125;; // 修改原型指向 Object.setPrototypeOf(chalk, Chalk.prototype); Object.setPrototypeOf(chalk.template, chalk); // 定义constructor，用于生成新的Chalk实例 // e.g. const ctx = new chalk.constructor(&#123;enabled: false&#125;); chalk.template.constructor = Chalk; return chalk.template; &#125; applyOptions(this, options);&#125; 3. stylesstyles可以说是所有使用方法的集合，因为所有的使用方法都是通过Object.defineProperties(xxx, styles)生成的。 styles到底长什么样呢？12345678910111213141516171819202122// styles结构示例&#123; red: &#123; get() &#123; return build.call(...); &#125; &#125;, black: &#123; get() &#123; return build.call(...); &#125; &#125;, // 颜色转换方法与直接取颜色值使用方法不同，结构也有所差异 ansi: &#123; get() &#123; return function() &#123; return build.call(...); &#125; &#125; &#125; ...&#125; 下图是在vsCode中断点截取的styles的构造 我们在使用chalk时的一个例子就是console.log(clalk.red(&#39;Hello&#39;)),通过上面的原型结构我们知道chalk.red其实就是调用了Chalk.prototype.red,那具体做了什么呢，接着看源码第224行：1Object.defineProperties(Chalk.prototype, styles); 其实为了将styles的所有方法实现在原型上，所以作者才用get(){}属性的，如果不懂的话去查defineProperties方法。 4.styles由来从源码55 ~ 115行，可以看出，ansi-styles模块就是其由来（也就是源码开头定义的ansiStyles）。这个模块定义了每个颜色对应的ANSI控制码,并从color-convert模块生成了一系列颜色转换工具函数，也就是chalk中的hex()、rbg()等方法的由来； 123456789101112131415161718192021222324// ansiStyles结构&#123; // 颜色 bgBlack: &#123; open: '\u001b[40m', close: '\u001b[49m', closeRe: /\\u001b\[49m/g // 这个是chalk源码94行添加的，不属于ansi-styles模块自有 &#125;, ... // color模块 指ANSI控制码 31-37 color: &#123; ... &#125;, // bgColor模块 指ANSI控制码 40-47 bgColor: &#123; ... &#125;, // modifier模块 指ANSI控制码 0-8 modifier: &#123; bold: &#123; ... &#125;, ... &#125; 6. 链式操作的实现console.log(chalk.red.underline(&#39;Hello&#39;))这种操作是如何实现的呢可以看下最初的图，其实里面已经描述的很清楚了，下面从源码讲解下：123456789101112131415161718192021222324252627282930313233// 1. styles每个方法的定义styles[key] = &#123; get() &#123; const codes = ansiStyles[key]; // 每个方法其实都返回了build函数的执行结果，即builder return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key); &#125;&#125;;// 2. 定义builder的原型const proto = Object.defineProperties(() =&gt; &#123;&#125;, styles);function build(_styles, _empty, key) &#123; const builder = function () &#123; return applyStyle.apply(builder, arguments); &#125;; ... // `__proto__` is used because we must return a function, but there is // no way to create a function with a different prototype // builder的原型指向为proto builder.__proto__ = proto; // eslint-disable-line no-proto return builder;&#125;// 3. 生成Chalk原型// 可以看出proto和Chalk其实一模一样Object.defineProperties(Chalk.prototype, styles);// 总结// 因为每个builder方法原型都指向了proto，proto中的方法又都是builder函数，即原型又指向proto,构成无限循环,所以可以无限链式调用chalk.red.underline -&gt; Chalk.prototype.red -&gt; builder方法(即red方法) -&gt; builder原型指向proto -&gt; builder.__proto__.underline 7. 返回最终调用返回结果就是返回了一个包含ANSI控制码的字符串e.g. &quot;\u001b[31m\u001b[4m Hello \u001b[24m\u001b[39m&quot;(红色带下划线) 其实就是在每次调用后再this._styles结构中增加了每种修饰的open与close]]></content>
      <categories>
        <category>vue-cli</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
</search>
